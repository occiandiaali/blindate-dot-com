"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateView = void 0;
exports.createView = createView;
const symbols_1 = require("../types/symbols");
const annotations_1 = require("../annotations");
const spec_1 = require("../encoding/spec");
const Metadata_1 = require("../Metadata");
function createView() {
    return new StateView();
}
class StateView {
    constructor() {
        /**
         * List of ChangeTree's that are visible to this view
         */
        this.items = new WeakSet();
        /**
         * List of ChangeTree's that are invisible to this view
         */
        this.invisible = new WeakSet();
        /**
         * Manual "ADD" operations for changes per ChangeTree, specific to this view.
         * (This is used to force encoding a property, even if it was not changed)
         */
        this.changes = new Map();
    }
    // TODO: allow to set multiple tags at once
    add(obj, tag = annotations_1.DEFAULT_VIEW_TAG, checkIncludeParent = true) {
        if (!obj[symbols_1.$changes]) {
            console.warn("StateView#add(), invalid object:", obj);
            return this;
        }
        // FIXME: ArraySchema/MapSchema do not have metadata
        const metadata = obj.constructor[Symbol.metadata];
        const changeTree = obj[symbols_1.$changes];
        this.items.add(changeTree);
        // add parent ChangeTree's
        // - if it was invisible to this view
        // - if it were previously filtered out
        if (checkIncludeParent && changeTree.parent) {
            this.addParentOf(changeTree, tag);
        }
        //
        // TODO: when adding an item of a MapSchema, the changes may not
        // be set (only the parent's changes are set)
        //
        let changes = this.changes.get(changeTree.refId);
        if (changes === undefined) {
            changes = {};
            this.changes.set(changeTree.refId, changes);
        }
        // set tag
        if (tag !== annotations_1.DEFAULT_VIEW_TAG) {
            if (!this.tags) {
                this.tags = new WeakMap();
            }
            let tags;
            if (!this.tags.has(changeTree)) {
                tags = new Set();
                this.tags.set(changeTree, tags);
            }
            else {
                tags = this.tags.get(changeTree);
            }
            tags.add(tag);
            // Ref: add tagged properties
            metadata?.[symbols_1.$fieldIndexesByViewTag]?.[tag]?.forEach((index) => {
                if (changeTree.getChange(index) !== spec_1.OPERATION.DELETE) {
                    changes[index] = spec_1.OPERATION.ADD;
                }
            });
        }
        else {
            const isInvisible = this.invisible.has(changeTree);
            const changeSet = (changeTree.filteredChanges !== undefined)
                ? changeTree.allFilteredChanges
                : changeTree.allChanges;
            for (let i = 0, len = changeSet.operations.length; i < len; i++) {
                const index = changeSet.operations[i];
                if (index === undefined) {
                    continue;
                } // skip "undefined" indexes
                const op = changeTree.indexedOperations[index] ?? spec_1.OPERATION.ADD;
                const tagAtIndex = metadata?.[index].tag;
                if (!changeTree.isNew && // new structures will be added as part of .encode() call, no need to force it to .encodeView()
                    (isInvisible || // if "invisible", include all
                        tagAtIndex === undefined || // "all change" with no tag
                        tagAtIndex === tag // tagged property
                    ) &&
                    op !== spec_1.OPERATION.DELETE) {
                    changes[index] = op;
                }
            }
        }
        // Add children of this ChangeTree to this view
        changeTree.forEachChild((change, index) => {
            // Do not ADD children that don't have the same tag
            if (metadata &&
                metadata[index].tag !== undefined &&
                metadata[index].tag !== tag) {
                return;
            }
            this.add(change.ref, tag, false);
        });
        return this;
    }
    addParentOf(childChangeTree, tag) {
        const changeTree = childChangeTree.parent[symbols_1.$changes];
        const parentIndex = childChangeTree.parentIndex;
        if (!this.items.has(changeTree)) {
            // view must have all "changeTree" parent tree
            this.items.add(changeTree);
            // add parent's parent
            const parentChangeTree = changeTree.parent?.[symbols_1.$changes];
            if (parentChangeTree && (parentChangeTree.filteredChanges !== undefined)) {
                this.addParentOf(changeTree, tag);
            }
            // // parent is already available, no need to add it!
            // if (!this.invisible.has(changeTree)) { return; }
        }
        // add parent's tag properties
        if (changeTree.getChange(parentIndex) !== spec_1.OPERATION.DELETE) {
            let changes = this.changes.get(changeTree.refId);
            if (changes === undefined) {
                changes = {};
                this.changes.set(changeTree.refId, changes);
            }
            if (!this.tags) {
                this.tags = new WeakMap();
            }
            let tags;
            if (!this.tags.has(changeTree)) {
                tags = new Set();
                this.tags.set(changeTree, tags);
            }
            else {
                tags = this.tags.get(changeTree);
            }
            tags.add(tag);
            changes[parentIndex] = spec_1.OPERATION.ADD;
        }
    }
    remove(obj, tag = annotations_1.DEFAULT_VIEW_TAG) {
        const changeTree = obj[symbols_1.$changes];
        if (!changeTree) {
            console.warn("StateView#remove(), invalid object:", obj);
            return this;
        }
        this.items.delete(changeTree);
        const ref = changeTree.ref;
        const metadata = ref.constructor[Symbol.metadata];
        let changes = this.changes.get(changeTree.refId);
        if (changes === undefined) {
            changes = {};
            this.changes.set(changeTree.refId, changes);
        }
        if (tag === annotations_1.DEFAULT_VIEW_TAG) {
            // parent is collection (Map/Array)
            const parent = changeTree.parent;
            if (!Metadata_1.Metadata.isValidInstance(parent)) {
                const parentChangeTree = parent[symbols_1.$changes];
                let changes = this.changes.get(parentChangeTree.refId);
                if (changes === undefined) {
                    changes = {};
                    this.changes.set(parentChangeTree.refId, changes);
                }
                // DELETE / DELETE BY REF ID
                changes[changeTree.parentIndex] = spec_1.OPERATION.DELETE;
            }
            else {
                // delete all "tagged" properties.
                metadata[symbols_1.$viewFieldIndexes].forEach((index) => changes[index] = spec_1.OPERATION.DELETE);
            }
        }
        else {
            // delete only tagged properties
            metadata[symbols_1.$fieldIndexesByViewTag][tag].forEach((index) => changes[index] = spec_1.OPERATION.DELETE);
        }
        // remove tag
        if (this.tags && this.tags.has(changeTree)) {
            const tags = this.tags.get(changeTree);
            if (tag === undefined) {
                // delete all tags
                this.tags.delete(changeTree);
            }
            else {
                // delete specific tag
                tags.delete(tag);
                // if tag set is empty, delete it entirely
                if (tags.size === 0) {
                    this.tags.delete(changeTree);
                }
            }
        }
        return this;
    }
    has(obj) {
        return this.items.has(obj[symbols_1.$changes]);
    }
    hasTag(ob, tag = annotations_1.DEFAULT_VIEW_TAG) {
        const tags = this.tags?.get(ob[symbols_1.$changes]);
        return tags?.has(tag) ?? false;
    }
}
exports.StateView = StateView;
//# sourceMappingURL=StateView.js.map